\documentclass{easychair}

\usepackage{fullpage}

\title{Safe smooth paths between straight line obstacles}
\author{Yves Bertot}
\institute{Inria Université Côte d'Azur}
\begin{document}
\maketitle
\section{Introduction}
We wish to present a comprehensive Coq program
to compute trajectories for a point between obstacles that are given by straight
line segments.  The Coq program contains four phases:
\begin{enumerate}
\item The obstacles are sorted in a sequence of {\em events}
\item The working space is decomposed into cells that are guaranteed to not contain
 any obstacle,
\item Given a source and a target point, a straight line trajectory is generated,
when possible
\item The angles of the straight line trajectory are then rounded using Bezier curves
\end{enumerate}
This algorithm works under the following assumption:
\begin{itemize}
\item There are two segments {\tt top} and {\tt bottom}, which define a box containing
all the obstacles
\item The only intersections between segments are at their extremities
\item None of the obstacles is vertical (in other words, all segments link two points
where the first coordinate of one point is less than the first coordinate of the other)
\end{itemize}

The algorithm receives as inputs the top and bottom edges, the sequence of segments,
and two points describing the source and target of the expected trajectory.  All
points used as obstacl extremities or as source and target for the trajectory are
given by cartesian coordinates.  All computations can be done using rational numbers.

The result is either a sequence of trajectory elements or an exceptional value, called
{\tt None} , based
on the well-known {\tt option} datatype.  When the result is not {\tt None},
the following properties are guaranteed:
\begin{itemize}
\item Each of the trajectory elements is either a segment or Bezier curve,
\item The sequence of trajectory elements form a continuous path,
\item None of the trajectory elements has an intersection with either
the {\tt top} and {\tt bottom} edges or the obstracles.
\end{itemize}
This is work in progress, so that not all of these properties have been proved yet.
We shall provide animations of the various phases of this program.

\section{events}
The first and second phase combine to implement a {\em vertical cell decomposition}.
The mental model used to explain this algorithm is that a sweeping line moves from
left to right and stops every time an obstacle extremity is encountered.

To mimick this sweeping operation, we actually pre-process the sequence of segments
to obtain a sorted list of events, where each event is essentially the extremity
of one of the segments describing the obstacles.  This consists in taking as input
the list of obstacles and producing as output the sorted list of events.
The property that must be satisfied are:
\begin{itemize}
\item The list of events is sorted lexicographically
\item Every obstacle has its left and right point among the events
\item Every event contains a list of obstacles whose left point are on this event
\end{itemize}
\section{Vertical cells}
When processing the sequence of events, a sequence of open cells is maintained and a set
of closed cells is produced.  The open cells are cells where
the left-hand side is already known, but the right-hand side is not yet known because
the right extremities of the cells below and above these cells have not been process
yet.  The invariants that we expect for these collections are as follows:
\begin{itemize}
\item The open cells span the whole vertical line between the bottom and top edges
and they are vertically sorted
\item The high and low edges for each open cell encounter the sweeping line
\item All obstacles whose left point is left of the sweeping line are covered by the
top edge of one of the closed or open cells
\item All cells, whether open or closed are pairwise disjoint
\end{itemize}
The processing works by decomposing the sequencce of open cells into three sub-sequences
where the middle one contains all open cells that are in contact with the event being
processed.  These contact cells are closed and a new subsequences of cells is produced by
processing the list of obstacles whose left point is given by this event.  Special care
is taken to guarantee that the closed cells are non-empty, the problem happens when
two successive events are vertically aligned.
\section{Broken line trajectory}
Once the vertical cell decomposition is finished, we can start drawing trajectories
between arbitrary points in the work space.  This is done by finding the cells containing
the source and target points and then solving the problem jumping from cell to neighboring
cell.  This is performed by a simple breadth-first search algorithm in the discrete graph
where the nodes are the cells and there is an edge between two nodes if they share a
a vertical boundary (which are all safe to traverse, since there are no vertical obstacles).

For this part of the algorithm we call {\em doors} the vertical boundaries between two
adjacent cells, and we can easily transform a discrete path from cell to cell into a discrete
path between doors by a simple combinatorial operation.  Special care must be taken when
entering and leaving a cell through the same vertical.  In this case, we add an intermediate
visit to the center of the cell.

In the end we build a trajectory that is a sequence of straight line segments going from
middle of door to middle of door, with an occasional visit to a cell center.  This trajectory
contains angles.  The correctness of this trajectory is based on the property that it is
safe to move from a door into a cell to a door out of the cell.  This is immediate if the
doors are not on the same vertical and requires more work in the other case.  Still it
all relies on the fact that vertical cells are convex.

The properties that we expect to prove are as follows:
\begin{itemize}
\item Each straight line in the trajectory has its interior included in the
interior of closed cell
\item Each extremity of the straight lines is either in the center of a door
or at the center of a cell
\item The sequence of straight lines does provide a path from the source to
the target point.
\end{itemize}

\section{Making a smooth trajectory}
As part of the exercise, we study the task of transforming the angles of the trajectory into
smooth curves.  For this effect, we decided to use Bezier curves.  So our algorithm includes
the production of Bezier curves for each change of direction, and the verification that
the Bezier curve still remains inside the union of the two cells in connects and the door
between them.

Bezier curves are a strong tool to ensure smoothness of trajectories, because it is easy
to make a Bezier curve that is tangent to a straight line at its extremity.  Bezier curves
are defined by sequence of control points, and they maintain the following nice properties:
\begin{itemize}
\item The curve passes through the first and last control point
\item The is tangent to the straight line from the first and the second control point at
the first point (and symmetrically at the last control point)
\item The curve is contained inside the convex hull of the control points.
\end{itemize}
We use quadratic Bezier curves which use only three control points.  So the convex
hull we need to consider are triangles, and we only need to show that these
triangles are included in the safe space.  In practice, this only means checking
that each Bezier curve goes through the door they are supposed to cross.  Our
algorithm generates the midpoints of each straight line segment in the trajectory
to serve as extremities of each Bezier curve fragment.  The third (middle) control
point is given by the angle point in the initial broken-line trajectory.  This
provides an initial Bezier curve, which is not garanteed to satisfy the necessary
condition.

Initial Bezier curves depart significantly from the initial safe broken line
trajectory, and for this reason they may sometimes collide with the obstacles.
Our program contains a repair algorithm, that chooses a tighter Bezier curve
when collision is detected.  From our formal work perspective, this means that
we need to provide a collision detection procedure and prove that this collison
detection procedure is correct.  For the repair procedure, we also need to show
that it connects the same extremities in a continuous fashion.  For now, we
have mostly concentrated on the proof that the collision detection algorithm
is safe.  We don't check that it always accepts curves that are safe, because
this process may be extremely costly and it is often more practical to reject
a curve that goes too close to an obstacle, even if it does not theoretically
collide with it.
\end{document}


