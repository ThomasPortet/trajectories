\documentclass{easychair}

\title{Safe smooth paths between straight line obstacles}
\author{Yves Bertot}
\institute{Inria Université Côte d'Azur}
\begin{document}
\maketitle

One benefit of formal verification is the removal of design errors at early
stages of complex artefacts.  This is being used extensively for software,
where formal models can be so precise that there exists a direct production
process from the formal models to actually running software, and the results
are impressive.  We wish to
extend this to domains where the distance between the formal model and the
real application is bigger, because our knowledge of physics in incomplete,
the world needs to be represented through geometrical abstractions, and
there are limitations to what computers can compute accurately and what
sensors and actuators can do in terms of precision.

In short, we would like to apply formal methods to robots, but to begin with
we will look only at a question involving geometry.  
We wish to present a comprehensive Coq program
to compute trajectories for a point between obstacles that are given by straight
line segments.

\section{A combination of algorithms}
The Coq program contains four phases, where each corresponds to a different
algorithm.  For the first phases, the basic blocks are concerned with
converting the geometry of the problem into a discrete problem, using sorting
and a recursive treatment of the obtained sorted list.  The result of the
first two phases consists in a collection of cells, where each cell is
a convex polygon connected to neighbors by safe boundaries that can
be crossed with collision with the obstacles.  The problem becomes the problem
of moving between cells. This
is then used to construct an abstract view of the trajectory, viewed simply
as a path between cells.  For this phase, a
simple graph algorithm is used.  The trajectory is
then built first as a broken line from the extremities to boundaries
of the cells that contain them, and then between boundaries.  This
broken line already represents a possible path, which is easy to prove correct
thanks to the relations between convex polygons and straight line segments.
However, such a broken line is unsatisfactory
as a robot trajectory, because each corner would impose that the robot
stops to rotate and change direction.  A last phase is added to find
smooth curved lines in the vicinity of the broken line, and extra proofs are
required to show that the smooth trajectories still avoid collisions with
the obstacles.  This phase can itself be decomposed in two parts, where one
proposes a Bezier curve for testing, and the other checks that the given
Bezier curve is safe.  In case of failure of the check, a curve that is closer
to the initial broken line is proposed.  In case where the repetitive process
does not converge fast enough, it is possible to use the initial broken line as
a fallback solution.

\subsection{Producing a sequence of events}
The first objective is to produce a collection of cells with the following
properties:
\begin{enumerate}
\item The interior of each cell is free of obstacles
\item The parts of the boundaries of these cells that can be crossed
  safely to reach other cells are known precisely
\end{enumerate}
To achieve this objective, we took inspiration from an algorithm known as
{\em vertical cell decomposition} \cite{Latombe91}.  The intuitive
operational model of this algorithm is that a vertical line is
sweeping the working space from left to right.  When the extremity of
an obstacle segment or the intersection between two obstacle segments
is encountered, some internal view of the cells is updated, ultimately
producing a collection of closed cells.  To represent this sweeping
operations, we chose to implement a sorting algorithm that takes as
input the list of segments and produces as output a list of {\em
  events}.  Each event corresponds to an obstacle extremity and is
annotated with the sequence of segments that have this event as
leftmost extremity.

At this point in our explanation, note that we chose to
simplify the problem by assuming that segments never cross and never
overlap over a portion of their length.  This assumption is not hard
to satisfy, as it is possible to take a collection of segments which
do not satisfy this assumption and produce a new collection of
segments that contain exactly the same points of the plane but satisfy
the assumption.

The sorting algorithm works as follows: every time an new segment is
process, an event is inserted in the current sequence of events at the
right place so that this sequence is sorted lexicographically (first
coordinated, and then second coordinate).  If the event is already
present in the sequence, a new occurrence is {\em not} added, but if
this event is the left extremity of the currently processed
segment, this segment is added to the event annotation indicating all
segments whose left extremity is this event.

Another simplification to our presentation of the problem is that
vertical segments are not allowed in our input.  Again, we think that
it is possible to work around this limitation: If one wishes to add
vertical obstacles, only there extremities should be added as events
without outgoing edges in the sequence of events.  We expect the
cells to be created where a safe boundary appears between the two
events.  It is enough to remove this safe boundary from the cells to
avoid collisions with the corresponding vertical obstacle.  This
approach is not implemented in our current version of the algorithm.

We assume we are working in some ordered field to represent the
coordinates.  For the algorithm itself, we shall only use the field
operations.  For the proofs we need to use some properties of the order.
The data types that we need to create to describe our algorithm are as
follows:
\begin{itemize}
\item A datatype of points, which are ordered pairs of coordinates in the field,
\item A datatype of edges (for the obstacles), which are ordered pairs of
  points, with the invariant that the first coordinate of the first
  point is stricly smaller than the first coordinate of the second point,
\item A datatype of events, which have two components, the first is a
  point and the second is sequence of edges, all of which have this
  point as first extremity.
\end{itemize}
For this algorithm to be correct, we need to guarantee the following
properties:
\begin{itemize}
\item All segments of the initial collection of obstacles must be
  present among the outgoing edges of events in the output
\item All segments attached to a given event have this event as first
  extremity
\item The sequence of events is strictly sorted lexicographically, as
  a consequence each edge appears as outgoing edge of a single event.
\end{itemize}

Processing the sorted list of events then implements the idea of the
sweeping line from left to right.

\section{Producing cells}
When producing cells, we disinguish between closed and open cells.
The closed cells lie to the left of the sweeping line, they are
complete and have a well-defined left and right sides.  The open cells
stradle the sweeping line.  They have a well-defined left side,
but the right side is unknown, as it will be fixed when
processing later events.

At a given position of the sweeping line, there is an ordered sequence
of open cells.  For each of these cells, the bottom and the top
boundary are given by edges.  Each of the open cells also has a
left side, which was defined at the time the cell was created,
possibly when processing several examples that all lie on the same
vertical.

The processing of a new event works as follows:
\begin{enumerate}
\item The sequence of open cells is decomposed into three parts:
a first sequence of untouched cells, a second sequence of cells in
contact with the given event, and a third sequence of cells of
untouched cells
\item All cells in contact are closed: their right side is
  described and they are added to the collection of closed cells
\item If the given event has \(n\) ougoing edges, then \(n+1\) new
  open cells are created.  The outgoing edges are first sorted vertically.
  The first cell has for its low edge the
  same low edge as first cell in the first of the contact cells, and
  as high edge the first of the outgoing edges (after sorting).  The
  last new cell is similar but with the last outgoing edge and the
  high edge of the last of contact cells.  All other cells have a
  left side that is reduced to a single point.
\end{enumerate}
For this algorithm to work, we add an extra constraint on the data:
the whole working space is enclosed between a bottom and a top edge
that are long enough so that they define a rectancle with no contacts
with all other edges.

Special care must be taken to handle the case where events are
vertically aligned.  When this happens, the first naive version of our
algorithm produces cells that have the left side and the right side on the
same vertical line.  These cells are flat and do not satisfy two important
properties that we like about non-empty cells.  First in a non-flat cell,
any path from a safe point on the left side to a safe point on the
right side is safe.  Second, in a non-flat cell, any path to a safe
point on any side to the center of the cell is safe.

To recover these properties, we modified our algorithm to memorize the
position of the last processed event, together with the last opened
cell and the last closed cell.  When the current event is vertically
aligned with the last processed event, we can avoid creating a flat
closed cell by updating the last opened cell and the last closed
cell.  However, this adds complexity in the proofs about the
algorithm.

At the moment of writing these lines, this modified vertical cell
decomposition algorithm is still being proved correct.  We proceed by
showing that a collection of properties are invariant through the
processing of events.  The properties that we have proved invariant so
far are as follows:
\begin{itemize}
\item The sequence of open cells is sorted vertically, the cells are
  adjacent, and they cover the whole space between the bottom and top
  edges,
\item All low and high edge of the current open cells contain a point
that is vertically aligned with the currently processed event,
\item All cells are disjoint,
\item The obstacles are covered by the high edges of existing cells,
  closed or open and the outgoing edges of events that have not been
  processed yet.
\end{itemize}
The last two properties put together should be enough to guarantee
that the interior of all closed cells is safe.  We have yet to
understand how we will express and prove safety properties for points
on the left and right sides of closed cells.

For now, the left and right sides of closed edges are equiped with
list of points, where the first one belongs to the cell's high edge
and the last one belongs to the cells low edge.  The other points on
these lists correspond to extrimities of edges that end or start on
this side.  The points on the side of an edge that are distinct from
the elements of these lists are also safe.  The intervals between the
points of these lists correspond to vertical segments that are doors
between the cell and neighbor cells.  There is a safe horizontal
pasage between two cells if the left side of one cell and the right
side of the other have such a door in common.  We use this criterion
to construct a graph whose nodes are the cells and whose edges are
doors between one cell and the other.

\section{Making a broken line trajectory between two points}
With the graph of cells and doors between these cells, we can already
construct safe paths between two points in the space, which we shall
the source and target points for clarity.  We only need the source and
target to be either inside the same polygon made of obstacles, or
inside the work space and outside of any polygon.

The first step is to find the two cells that contain the source and
the target.  If these two cells are the same and the source and target
are on the interior, then it is enough draw a straight line segment from the
source to the target.

If the two cells are different, we can explore the graph to check for
the existence of a path in this graph from the source cell to the
target cell.  Ths path is composed of edges of the graph and each of
the graph edges is actually a door between two cells.  It is enough to
construct a sequence of paths between the middle points of each door
that is an element of this path.  If two successive doors are not on the same
vertical line, these two doors are on both sides a same cell.  A
straight segment from the middle of the first door to the middle of
the second door is a safe path in the interior of the cell (this
property would not be satisfied if the cell was flat).

When two successive doors are on the same verical line, a straight
line between the center of one door and the center of the other is
bound to be unsafe, because it will touch the lowest bound of the
highest of the two doors, and this lowest bound is the extremity of
some obstacle.  To avoid this, we build a path composed of two
segments.  The first segment goes from the middle of the first door to
the center of the cell.  The second segment goes from the center of
the cell to the middle of the second door.  Such a two segment path is
safe because the two exremities are safe, and the interior of these
paths lie inside the interior of the cell, which is safe.

For the formal proofs of this part, we have not started working on
this, but this should rely on the properties of convex sets, in
particular that any segment between two points of a convex set are in
this convex set.

\section{Making a smooth trajectory}
The trajectory described in the previous section is given by a
sequence of segments, where each segment shares an extremity with its
predecessor and the other extremity with its successor.  We shall call
these extremities the {\em corners} of the trajectory.  We wish to
replace each corner by a smooth curve, in such a way that successive
curve fragments align.

Such a property is easy to achieve with Bézier curves.  In our case,
it is enough to use quadratic Bézier curves.  A quadratic Bézier curve
is given by 3 points (in the same way that a polynomial of degree 2 is
given by three coefficients).  Given three points \(A\), \(B\), \(C\)
a point on the corresponding Bézier curve is given by choosing a
parameter \(t\) between 0 and 1 and computing three more points:
\(D\) is the barycenter of \(A\) with weight \(1 - t\) and \(B\) with
weight \(t\), \(E\) is the barycenter of \(B\) with weight \(1 - t\)
and \(C\) with weight \(t\), and \(F\) is the barycenter of \(D\) with
weight \(1-t\) and \(E\) with weight \(t\).  The point \(F\) is the
point on the Bézier curve for the parameter \(t\).  When \(t\) varies
between \(0\) and \(1\), the point moves on the Béier curve from \(A\)
to \(C\), generally without passing through \(B\).  The curve that one
obtains is tangent to the segment \((A,B)\) in \(A\) and tangent to
the segment \((B,C))\) in \(C\).

A broken line \(A\) \(B\) \(C\) \(D\) can be transformed into a smooth
curve by Adding a point \(M\) on the segment between \(B\) and \(C\)
and replacing the three segments \((A, B)\), \((B, C)\), and \((C,
D)\) by the two Bézier curves given by points \(A\) \(B\) \(M\) on the
one hand and \(M\) \(C\) \(D\) on the other hand.  These two curves
are smooth in their inside, and they connect in \(M\) in such a way
that their tangent is aligned with the segment \((B, C)\), and in the
same direction.

Our Bezier curve construction starts with a broken line that is safe,
but the curves stray away from the corners, and in doing so they may
collide with the obstacles.  We need two more algorithms, one to prove
that a Bézier curve stays in safe territory, and the other to repair
trajectories whose Bézier curve do collide with the obstacles.  We
designed two such algorithms.

These algorithms are based on a strong property of Bézier curves,
which we shall call the dichotomy property.  In the description above
where we showed how to construction the point \(F\) which belongs to
the Bézier curve, it turns out that the triplets \(A\) \(D\) \(F\) and
\(F\) \(E\) \(C\) define two new Bézier curves that decompose the
original Bézier curve in two complementary subsets \(A\) \(D\) \(F\)
covers all the points of \(A\) \(B\) \(C\) for a parameter \(t' \leq
t\), while \(F\) \(E\) \(C\) covers all the points of \(A\) \(B\)
\(C\) for a parameter \(t'\geq t\).  The convex hull for \(A\) \(D\)
\(F\) is much smaller than the convex hull for \(A\) \(B\) \(C\), and
thus the dichotomy operation makes it possible to replace a gross
approximation of the Bezier curve by a more precise one.  Our checking
algorithm repeats this dichotomy operation until it gets enough
information to conclude that there is a guarantee that the Bezier curve
is included in the union of the interior of two cells and the door
between these cells, or that there is a gurantee that the Bézier curve
steps out of this union, in which case we have proved that the Bézier
curve is unsafe.

When we have an unsafe Bézier curve, we can repair the situation by
replacing the Bezier curve \(A\) \(B\) \(C\) by the composite path
obtained by adding two new points \(M\) and \(N\) which are the
centers of \((A,B)\) and \((B,C)\) respectively, and taking the
segment \((A,M)\), the Bézier curve \(M\) \(B\) \(N\), and finally the
segment \((N, C)\).  This composite path is smooth, because the
junctions at \(M\) and \(N\) have the same tangent and direction, and
it is also closer to the initial broken line trajectory.  There is no
guarantee that this new path is safe, so it needs to be checked again,
and if need be the replacement process can be repeeted.  Ultimately,
if the replacement process were repeated indefinitely the limit of the
smooth path would the broken line path.

In our program, we first produce a candidate Bezier curve for each
corner, and we then check whether this curve is safe.  If not, we
produce Bezier curves, that are closer to the broken line and
repeatedly check their safety.  After alimited number of iterations,
the program falls back to the initial broken line corner if need be.
We only wish to prove that the checking procedure is correct.  For
this program, we will not be able to prove that resulting trajectory
is smooth.

Many of the elementary components were developed by collaborators:
Thomas Portet worked on the vertical cell decomposition algorithm and
Quentin Vermande worked on the general properties of Bezier curves and
collisions with a convex hull.  Some parts of the program also rely on
finite maps provided by the Coq standard library.

\section{Exploiting the program and visual feedback}
This program can be run inside Coq, using rational numbers for the numbers system.
The output can be displayed by simply traversing the output data structure and generating
simple postscript commands for each of the straight line or Bezier curve segment.  Our
program uses quadratic Bezier curves, while postscript supports cubic Bezier curves, but
converting from one to the other is easy.  A Javascript user-interface for this geometric
program is also under study.
\end{document}


